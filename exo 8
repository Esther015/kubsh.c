  GNU nano 7.2                                                                                                        kubsh.c                                                                                                                 
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<signal.h>
#include<unistd.h>
#include<sys/wait.h>

#include<readline/readline.h>
#include <readline/history.h>

#define HISTORY_FILE ".kubsh_history"

sig_atomic_t signal_received = 0;

void debug(char *line){
 printf("%s\n",line);
}
void sig_handler(int signum){
 signal_received = signum;
 printf("Configuration reloaded");
}

void print_env_var(const char * var_name){
  if (var_name  == NULL || strlen(var_name)== 0 ){
    printf("Usage: \\e $VARNAME\n");
    return ;
}
  
  if(var_name[0] =='$'){
    var_name++;
  }
  const char *value= getenv(var_name);
  if(value ==NULL){
    printf("Variable '%s' not found.\n", var_name);
    return;
  }

  char *copy = strdup(value);
  if(!copy){
   perror("strdup");
   return;
  }
 printf("%s=\n",var_name);

 char *token= strtok(copy, ":");
 if(token && strchr (value , ':')){
    while(token!=NULL){
   printf("- %s\n",token);
   token = strtok(NULL, ":");
    }
 }else{
   printf("%s\n",copy);
 }
 free(copy); 





25.10.2025

  GNU nano 7.2                         kubsh.c                                  
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<signal.h>
#include<unistd.h>
#include<sys/wait.h>

#include<readline/readline.h>
#include <readline/history.h>

#define HISTORY_FILE ".kubsh_history"

sig_atomic_t signal_received = 0;

void debug(char *line){
 printf("%s\n",line);
}
void sig_handler(int signum){
 signal_received = signum;
 printf("Configuration reloaded");
}

void print_env_var(const char * var_name){
  if (var_name  == NULL || strlen(var_name)== 0 ){
    printf("Usage: \\e $VARNAME\n");
    return ; }
}
  
  if(var_name[0] =='$'){
    var_name++;
  }
  const char *value= getenv(var_name);
  if(value ==NULL){
    printf("Variable '%s' not found.\n", var_name);
    return;
  }if(var_name[0] =='$'){
    var_name++;
  }
  const char *value= getenv(var_name);
  if(value ==NULL){
    printf("Variable '%s' not found.\n", var_name);
    return;
  }

  char *copy = strdup(value);
  if(!copy){
   perror("strdup");
   return;
  }
  printf("%s=\n",var_name);

  char *token= strtok(copy, ":");
  if(token && strchr (value , ':')){
while(token!=NULL){
      printf("- %s\n",token);
      token = strtok(NULL, ":");
    }
  }else{
    printf("%s\n",copy);
  }
  free(copy); 
}
void execute_command(const char *input){
char *args[64];
int i=0;
char *token = strtok(input,"");
 while(token !=NULL && i<63){
   args[i++]= token;
   token = strtok(NULL, " ");
   args[i]=NULL;
  if (args[0] == NULL)
return;

  pid_t pid =fork();
  if (pid == 0){
    execvp(args[0], args);
    perror("execvp");
    exit(EXIT_FAILURE);
  } else if(pid>0){
     int status;
     waitpid(pid, &status, 0);
  } else{
    perror("fork"); 
  }

}
int main(){
  signal(SIGSTOP, sig_handler);
  read_history(HISTORY_FILE);
  printf("kubsh started.\n");

  char *input;
 
  while(1){
    input= readline("$ ");
   if (signal_received){
     signal_received= 0;
     continue;
   }
   if (input == NULL){
      break;
   }
   add_history(input);
   if (!strcmp(input, "\\q")){
      break;
   }else if (strncmp( input, "debug",6) == 0){
debug(input+6);
   }
   else if (strncmp(input, "\\e $", 4)==0){
      print_env_var(input+ 3);
   } else {
      execute_command(input);
   }
    free (input);
  }
  write_history(HISTORY_FILE);
  return 0;
}
}


